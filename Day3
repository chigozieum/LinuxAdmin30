### Day 3: Mastering File Permissions & Ownership in Linux - The Complete Guide

## Introduction: The Foundation of Linux Security

Welcome to Day 3 of our 30-Day Linux Engineer Training Series. Today, we're diving deep into one of the most fundamental aspects of Linux system security: file permissions and ownership. This knowledge forms the cornerstone of Linux security architecture and is essential for any Linux engineer.

In Linux, everything is a fileâ€”regular files, directories, devices, sockets, and pipes. The permission system controls who can access these files and what they can do with them. Mastering this system is crucial for maintaining secure systems, troubleshooting access issues, and implementing proper security policies.

### Why File Permissions Matter

Before we dive into the technical details, let's understand why file permissions are so critical:

- **Security Isolation**: Prevents users from accessing or modifying each other's files
- **System Integrity**: Protects critical system files from unauthorized changes
- **Data Protection**: Ensures sensitive information is only accessible to authorized users
- **Service Segregation**: Allows services to run with minimal necessary privileges
- **Compliance**: Many regulatory frameworks require proper file access controls
- **Multi-User Environment**: Enables multiple users to work on the same system safely


A single misconfigured permission can lead to data breaches, system compromise, or application failures. Let's ensure you have the knowledge to prevent these issues.

## Part 1: Understanding the Linux Permission Model

### The Basic Permission Structure

In Linux, every file and directory has three sets of permissions, applied to three different categories of users:

1. **Owner (u)**: The user who owns the file
2. **Group (g)**: The group assigned to the file
3. **Others (o)**: Everyone else on the system


For each of these categories, there are three basic permission types:

1. **Read (r)**: Permission to read the file contents or list directory contents
2. **Write (w)**: Permission to modify the file or create/delete files in a directory
3. **Execute (x)**: Permission to run the file as a program or access files within a directory


### Reading Permission Notation

When you run `ls -l`, you'll see permissions displayed like this:

```plaintext
-rwxr-xr--  1 user1  group1  4096 Apr  5 10:30 example.sh
```

Let's break down the permission string `-rwxr-xr--`:

- First character: File type

- `-`: Regular file
- `d`: Directory
- `l`: Symbolic link
- `c`: Character device
- `b`: Block device
- `s`: Socket
- `p`: Named pipe



- Characters 2-4 (`rwx`): Owner permissions

- `r`: Owner can read
- `w`: Owner can write
- `x`: Owner can execute



- Characters 5-7 (`r-x`): Group permissions

- `r`: Group can read
- `-`: Group cannot write
- `x`: Group can execute



- Characters 8-10 (`r--`): Others permissions

- `r`: Others can read
- `-`: Others cannot write
- `-`: Others cannot execute





### Numeric (Octal) Representation

Permissions can also be represented as octal numbers, where:

- Read (r) = 4
- Write (w) = 2
- Execute (x) = 1


By adding these values, we get a single digit representing the permissions for each category:

- `rwx` = 4+2+1 = 7
- `r-x` = 4+0+1 = 5
- `r--` = 4+0+0 = 4
- `---` = 0+0+0 = 0


So the permission string `rwxr-xr--` translates to the octal notation `754`:

- Owner: `rwx` = 7
- Group: `r-x` = 5
- Others: `r--` = 4


### Common Permission Patterns

Here are some commonly used permission patterns:

- `644` (`rw-r--r--`): Regular files that don't need execution
- `755` (`rwxr-xr-x`): Directories and executable files
- `600` (`rw-------`): Private files (only owner can read/write)
- `700` (`rwx------`): Private directories (only owner can access)
- `777` (`rwxrwxrwx`): Full access for everyone (generally avoided for security reasons)
- `444` (`r--r--r--`): Read-only for everyone


### Directory Permissions

Directory permissions work slightly differently than file permissions:

- **Read (r)**: Allows listing the directory contents (with `ls`)
- **Write (w)**: Allows creating, deleting, or renaming files within the directory
- **Execute (x)**: Allows accessing the directory and its contents (crucial for traversing directories)


Without execute permission on a directory, you cannot access files within it, even if you have permissions on those files.

## Part 2: Essential Permission Management Commands

### Viewing Permissions

```shellscript
# List files with permissions
ls -l file.txt

# List all files including hidden ones
ls -la

# Recursive listing
ls -lR /path/to/directory

# Show permissions in octal format
stat -c "%a %n" file.txt
```

### Changing Permissions with chmod

The `chmod` command changes the permissions of files and directories.

#### Symbolic Mode

```shellscript
# Add execute permission for owner
chmod u+x script.sh

# Remove write permission for group
chmod g-w file.txt

# Add read for others, remove write for group
chmod o+r,g-w file.txt

# Set exact permissions (remove any not specified)
chmod u=rwx,g=rx,o= file.txt
```

Symbolic mode uses these operators:

- `+`: Add permissions
- `-`: Remove permissions
- `=`: Set exact permissions


And these user categories:

- `u`: Owner (user)
- `g`: Group
- `o`: Others
- `a`: All (equivalent to ugo)


#### Octal Mode

```shellscript
# Set permissions to rw-r--r--
chmod 644 file.txt

# Set permissions to rwxr-xr-x
chmod 755 script.sh

# Set permissions to rwx------
chmod 700 private_directory
```

#### Recursive Permission Changes

```shellscript
# Change permissions recursively
chmod -R 755 /path/to/directory

# Change only directories to 755 and files to 644
find /path/to/directory -type d -exec chmod 755 {} \;
find /path/to/directory -type f -exec chmod 644 {} \;
```

### Changing Ownership with chown

The `chown` command changes the owner and/or group of files and directories.

```shellscript
# Change owner
chown user1 file.txt

# Change owner and group
chown user1:group1 file.txt

# Change only the group
chown :group1 file.txt

# Change recursively
chown -R user1:group1 /path/to/directory
```

### Changing Group with chgrp

The `chgrp` command changes only the group ownership.

```shellscript
# Change group
chgrp group1 file.txt

# Change group recursively
chgrp -R group1 /path/to/directory
```

### Default Permissions with umask

The `umask` command sets the default permissions for newly created files and directories.

```shellscript
# View current umask
umask

# Set new umask
umask 022
```

The umask value is subtracted from the maximum default permissions:

- For files: 666 (rw-rw-rw-)
- For directories: 777 (rwxrwxrwx)


So with a umask of 022:

- New files get 644 (666 - 022 = 644, or rw-r--r--)
- New directories get 755 (777 - 022 = 755, or rwxr-xr-x)


Common umask values:

- `022`: Standard for most systems (files: 644, directories: 755)
- `027`: More restrictive (files: 640, directories: 750)
- `077`: Maximum privacy (files: 600, directories: 700)


## Part 3: Advanced Permission Concepts

### Special Permission Bits

Beyond the basic read, write, and execute permissions, Linux has three special permission bits:

#### 1. Setuid Bit (SUID)

When set on an executable file, the program runs with the permissions of the file owner, not the user who executes it.

```shellscript
# Set SUID bit
chmod u+s file
# or
chmod 4755 file  # 4 is for SUID

# Identify SUID files
find / -perm -4000 -type f
```

In `ls -l` output, SUID appears as an `s` in place of the owner's execute bit:

```plaintext
-rwsr-xr-x
```

Example: The `passwd` command has SUID set, allowing regular users to update their passwords in `/etc/shadow` (which is owned by root).

#### 2. Setgid Bit (SGID)

When set on an executable file, the program runs with the permissions of the file's group.
When set on a directory, new files created in that directory inherit the directory's group.

```shellscript
# Set SGID bit
chmod g+s file_or_directory
# or
chmod 2755 file_or_directory  # 2 is for SGID

# Identify SGID files
find / -perm -2000 -type f
```

In `ls -l` output, SGID appears as an `s` in place of the group's execute bit:

```plaintext
-rwxr-sr-x
```

Example: A shared directory for a project team can use SGID to ensure all files created remain accessible to the team.

#### 3. Sticky Bit

When set on a directory, only the file owner, directory owner, or root can delete or rename files within it, even if others have write permissions.

```shellscript
# Set sticky bit
chmod +t directory
# or
chmod 1777 directory  # 1 is for sticky bit

# Identify directories with sticky bit
find / -perm -1000 -type d
```

In `ls -l` output, the sticky bit appears as a `t` in place of the others' execute bit:

```plaintext
drwxrwxrwt
```

Example: The `/tmp` directory has the sticky bit set, allowing multiple users to create files but preventing them from deleting each other's files.

### Combining Special Permission Bits

You can combine these special bits with regular permissions:

```shellscript
# Set SUID, SGID, and regular permissions
chmod 6755 file  # 6 = 4 (SUID) + 2 (SGID)

# Set all three special bits
chmod 7777 directory  # 7 = 4 (SUID) + 2 (SGID) + 1 (sticky bit)
```

## Part 4: Extended Access Control Lists (ACLs)

Standard Linux permissions are limited to one owner, one group, and others. ACLs provide more granular control by allowing you to specify permissions for multiple users and groups.

### Installing ACL Support

```shellscript
# Debian/Ubuntu
apt-get install acl

# RHEL/CentOS
yum install acl

# Make sure your filesystem supports ACLs
# Most modern filesystems do, but you might need to add 'acl' to mount options
```

### Viewing ACLs

```shellscript
# View ACLs for a file
getfacl file.txt

# Sample output
# file: file.txt
# owner: user1
# group: group1
# user::rw-
# user:user2:r--
# group::r--
# group:group2:rw-
# mask::rw-
# other::r--
```

### Setting ACLs

```shellscript
# Give a specific user read and write access
setfacl -m u:username:rw- file.txt

# Give a specific group read access
setfacl -m g:groupname:r-- file.txt

# Set default ACLs for new files in a directory
setfacl -d -m u:username:rwx directory

# Apply recursively to all files and directories
setfacl -R -m u:username:rwx directory
```

### Removing ACLs

```shellscript
# Remove specific ACL entry
setfacl -x u:username file.txt

# Remove all ACLs
setfacl -b file.txt
```

### ACL Mask

The ACL mask defines the maximum permissions that can be granted by any ACL entry for users and groups (except the owner). It's automatically calculated when you set ACLs, but you can also set it explicitly:

```shellscript
# Set the mask
setfacl -m m::rw- file.txt
```

### Backing Up and Restoring ACLs

```shellscript
# Backup ACLs
getfacl -R /path/to/directory > acl_backup.txt

# Restore ACLs
setfacl --restore=acl_backup.txt
```

## Part 5: Practical Permission Management Strategies

### Web Server Permissions

For a typical web server setup:

```shellscript
# Set ownership
chown -R www-data:www-data /var/www/html

# Set directory permissions
find /var/www/html -type d -exec chmod 755 {} \;

# Set file permissions
find /var/www/html -type f -exec chmod 644 {} \;

# Make specific directories writable for uploads
chmod 775 /var/www/html/uploads
```

### Shared Directory Setup

For a directory shared by multiple users in the same group:

```shellscript
# Create the directory
mkdir /shared

# Set ownership
chown root:shared_group /shared

# Set permissions with SGID to maintain group ownership
chmod 2775 /shared

# Set default ACLs
setfacl -d -m g:shared_group:rwx /shared
```

### Securing Configuration Files

For sensitive configuration files:

```shellscript
# Set restrictive permissions
chmod 600 /etc/app/config.conf

# If the file needs to be read by a service
chown root:service_group /etc/app/config.conf
chmod 640 /etc/app/config.conf
```

### Application Deployment Permissions

When deploying applications:

```shellscript
# Set ownership to the application user
chown -R app_user:app_group /opt/application

# Set appropriate permissions
find /opt/application -type d -exec chmod 750 {} \;
find /opt/application -type f -exec chmod 640 {} \;

# Make scripts executable
find /opt/application -name "*.sh" -exec chmod 750 {} \;
```

## Part 6: Comprehensive Permission Audit and Management Scripts

### Script 1: Permission Audit Tool

This script audits file permissions in a directory and reports potential security issues:

```shellscript
#!/bin/bash
#
# permission_audit.sh - Audit file permissions for security issues
# Usage: ./permission_audit.sh /path/to/directory

# Logging setup
LOG_FILE="permission_audit_$(date +%Y%m%d).log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Logging function
log_message() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Check if directory is provided
if [[ $# -ne 1 ]]; then
    echo "Usage: $0 /path/to/directory"
    exit 1
fi

TARGET_DIR="$1"

# Check if directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    handle_error "$TARGET_DIR is not a directory"
fi

log_message "Starting permission audit for $TARGET_DIR"

# Create report header
echo "=======================================" >> "$LOG_FILE"
echo "PERMISSION AUDIT REPORT" >> "$LOG_FILE"
echo "Directory: $TARGET_DIR" >> "$LOG_FILE"
echo "Date: $(date)" >> "$LOG_FILE"
echo "=======================================" >> "$LOG_FILE"
echo "" >> "$LOG_FILE"

# Check world-writable files
log_message "Checking for world-writable files..."
echo "World-writable files (permissions include 'w' for others):" >> "$LOG_FILE"
echo "-------------------------------------------------------" >> "$LOG_FILE"
world_writable=$(find "$TARGET_DIR" -type f -perm -002 -not -path "*/\.*" | sort)

if [[ -z "$world_writable" ]]; then
    echo "None found (good)" >> "$LOG_FILE"
else
    echo "$world_writable" >> "$LOG_FILE"
    log_message "WARNING: Found $(echo "$world_writable" | wc -l) world-writable files"
fi
echo "" >> "$LOG_FILE"

# Check world-writable directories
log_message "Checking for world-writable directories..."
echo "World-writable directories (permissions include 'w' for others):" >> "$LOG_FILE"
echo "------------------------------------------------------------" >> "$LOG_FILE"
world_writable_dirs=$(find "$TARGET_DIR" -type d -perm -002 -not -path "*/\.*" | sort)

if [[ -z "$world_writable_dirs" ]]; then
    echo "None found (good)" >> "$LOG_FILE"
else
    echo "$world_writable_dirs" >> "$LOG_FILE"
    log_message "WARNING: Found $(echo "$world_writable_dirs" | wc -l) world-writable directories"
fi
echo "" >> "$LOG_FILE"

# Check SUID files
log_message "Checking for SUID files..."
echo "SUID files (run as the file owner):" >> "$LOG_FILE"
echo "--------------------------------" >> "$LOG_FILE"
suid_files=$(find "$TARGET_DIR" -type f -perm -4000 | sort)

if [[ -z "$suid_files" ]]; then
    echo "None found" >> "$LOG_FILE"
else
    echo "$suid_files" >> "$LOG_FILE"
    log_message "NOTICE: Found $(echo "$suid_files" | wc -l) SUID files"
fi
echo "" >> "$LOG_FILE"

# Check SGID files
log_message "Checking for SGID files..."
echo "SGID files (run as the file group):" >> "$LOG_FILE"
echo "--------------------------------" >> "$LOG_FILE"
sgid_files=$(find "$TARGET_DIR" -type f -perm -2000 | sort)

if [[ -z "$sgid_files" ]]; then
    echo "None found" >> "$LOG_FILE"
else
    echo "$sgid_files" >> "$LOG_FILE"
    log_message "NOTICE: Found $(echo "$sgid_files" | wc -l) SGID files"
fi
echo "" >> "$LOG_FILE"

# Check unowned files
log_message "Checking for unowned files..."
echo "Files with no valid owner:" >> "$LOG_FILE"
echo "------------------------" >> "$LOG_FILE"
unowned_files=$(find "$TARGET_DIR" -nouser | sort)

if [[ -z "$unowned_files" ]]; then
    echo "None found (good)" >> "$LOG_FILE"
else
    echo "$unowned_files" >> "$LOG_FILE"
    log_message "WARNING: Found $(echo "$unowned_files" | wc -l) files with no valid owner"
fi
echo "" >> "$LOG_FILE"

# Check files with no valid group
log_message "Checking for files with no valid group..."
echo "Files with no valid group:" >> "$LOG_FILE"
echo "------------------------" >> "$LOG_FILE"
unowned_group=$(find "$TARGET_DIR" -nogroup | sort)

if [[ -z "$unowned_group" ]]; then
    echo "None found (good)" >> "$LOG_FILE"
else
    echo "$unowned_group" >> "$LOG_FILE"
    log_message "WARNING: Found $(echo "$unowned_group" | wc -l) files with no valid group"
fi
echo "" >> "$LOG_FILE"

# Check for executable files with liberal permissions
log_message "Checking for executable files with liberal permissions..."
echo "Executable files with liberal permissions:" >> "$LOG_FILE"
echo "---------------------------------------" >> "$LOG_FILE"
liberal_exes=$(find "$TARGET_DIR" -type f -perm -o+x | sort)

if [[ -z "$liberal_exes" ]]; then
    echo "None found (good)" >> "$LOG_FILE"
else
    echo "$liberal_exes" >> "$LOG_FILE"
    log_message "NOTICE: Found $(echo "$liberal_exes" | wc -l) executable files with liberal permissions"
fi
echo "" >> "$LOG_FILE"

# Check for files with ACLs
if command -v getfacl &> /dev/null; then
    log_message "Checking for files with ACLs..."
    echo "Files with ACLs:" >> "$LOG_FILE"
    echo "--------------" >> "$LOG_FILE"
    
    # Find files with ACLs
    files_with_acls=$(find "$TARGET_DIR" -type f -exec getfacl -p {} \; 2>/dev/null | grep -l "^user:" | sort)
    
    if [[ -z "$files_with_acls" ]]; then
        echo "None found" >> "$LOG_FILE"
    else
        echo "$files_with_acls" >> "$LOG_FILE"
        log_message "NOTICE: Found $(echo "$files_with_acls" | wc -l) files with ACLs"
    fi
    echo "" >> "$LOG_FILE"
else
    log_message "getfacl not available, skipping ACL check"
fi

# Summary
echo "=======================================" >> "$LOG_FILE"
echo "SUMMARY" >> "$LOG_FILE"
echo "=======================================" >> "$LOG_FILE"
echo "World-writable files: $(echo "$world_writable" | wc -l)" >> "$LOG_FILE"
echo "World-writable directories: $(echo "$world_writable_dirs" | wc -l)" >> "$LOG_FILE"
echo "SUID files: $(echo "$suid_files" | wc -l)" >> "$LOG_FILE"
echo "SGID files: $(echo "$sgid_files" | wc -l)" >> "$LOG_FILE"
echo "Files with no valid owner: $(echo "$unowned_files" | wc -l)" >> "$LOG_FILE"
echo "Files with no valid group: $(echo "$unowned_group" | wc -l)" >> "$LOG_FILE"
echo "Executable files with liberal permissions: $(echo "$liberal_exes" | wc -l)" >> "$LOG_FILE"
if command -v getfacl &> /dev/null; then
    echo "Files with ACLs: $(echo "$files_with_acls" | wc -l)" >> "$LOG_FILE"
fi
echo "" >> "$LOG_FILE"

log_message "Permission audit completed. Results saved to $LOG_FILE"
echo "Permission audit completed. Results saved to $LOG_FILE"

exit 0
```

### Script 2: Permission Remediation Tool

This script fixes common permission issues:

```shellscript
#!/bin/bash
#
# fix_permissions.sh - Fix common permission issues
# Usage: ./fix_permissions.sh /path/to/directory [--dry-run]

# Logging setup
LOG_FILE="permission_fixes_$(date +%Y%m%d).log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Logging function
log_message() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Check arguments
if [[ $# -lt 1 ]]; then
    echo "Usage: $0 /path/to/directory [--dry-run]"
    exit 1
fi

TARGET_DIR="$1"
DRY_RUN=false

if [[ "$2" == "--dry-run" ]]; then
    DRY_RUN=true
    log_message "Running in dry-run mode (no changes will be made)"
fi

# Check if directory exists
if [[ ! -d "$TARGET_DIR" ]]; then
    handle_error "$TARGET_DIR is not a directory"
fi

log_message "Starting permission remediation for $TARGET_DIR"

# Function to execute or simulate a command
execute_cmd() {
    local cmd="$1"
    local description="$2"
    
    log_message "$description: $cmd"
    
    if [[ "$DRY_RUN" == false ]]; then
        eval "$cmd"
        if [[ $? -eq 0 ]]; then
            log_message "SUCCESS: $description"
        else
            log_message "FAILED: $description"
        fi
    else
        log_message "DRY-RUN: Would execute: $cmd"
    fi
}

# Fix world-writable files
log_message "Fixing world-writable files..."
world_writable=$(find "$TARGET_DIR" -type f -perm -002)

for file in $world_writable; do
    # Get current permissions
    current_perm=$(stat -c "%a" "$file")
    
    # Calculate new permissions (remove write for others)
    new_perm=$((current_perm & ~2))
    
    execute_cmd "chmod $new_perm \"$file\"" "Removing world-writable permission from file $file ($current_perm -> $new_perm)"
done

# Fix world-writable directories (more carefully, as some might need to be world-writable)
log_message "Fixing world-writable directories..."
world_writable_dirs=$(find "$TARGET_DIR" -type d -perm -002)

for dir in $world_writable_dirs; do
    # Skip common directories that are typically world-writable
    if [[ "$dir" == "/tmp" || "$dir" == "/var/tmp" || "$dir" =~ /tmp$ ]]; then
        log_message "Skipping known world-writable directory: $dir"
        continue
    fi
    
    # Get current permissions
    current_perm=$(stat -c "%a" "$dir")
    
    # Calculate new permissions (remove write for others, keep sticky bit if present)
    if [[ $((current_perm & 1000)) -eq 1000 ]]; then
        # Has sticky bit
        new_perm=$(( (current_perm & ~2) | 1000 ))
    else
        # No sticky bit
        new_perm=$((current_perm & ~2))
    fi
    
    execute_cmd "chmod $new_perm \"$dir\"" "Removing world-writable permission from directory $dir ($current_perm -> $new_perm)"
done

# Fix unowned files
log_message "Fixing unowned files..."
unowned_files=$(find "$TARGET_DIR" -nouser)

for file in $unowned_files; do
    execute_cmd "chown root:root \"$file\"" "Setting ownership of unowned file $file to root:root"
done

# Fix files with no valid group
log_message "Fixing files with no valid group..."
unowned_group=$(find "$TARGET_DIR" -nogroup)

for file in $unowned_group; do
    # Get current owner
    current_owner=$(stat -c "%U" "$file")
    
    execute_cmd "chown $current_owner:root \"$file\"" "Setting group of file $file with no valid group to root"
done

# Fix executable files with liberal permissions
log_message "Fixing executable files with liberal permissions..."
liberal_exes=$(find "$TARGET_DIR" -type f -perm -o+x)

for file in $liberal_exes; do
    # Get current permissions
    current_perm=$(stat -c "%a" "$file")
    
    # Calculate new permissions (remove execute for others)
    new_perm=$((current_perm & ~1))
    
    execute_cmd "chmod $new_perm \"$file\"" "Removing execute permission for others from file $file ($current_perm -> $new_perm)"
done

# Set standard permissions for common file types
log_message "Setting standard permissions for common file types..."

# Configuration files
execute_cmd "find \"$TARGET_DIR\" -name \"*.conf\" -type f -exec chmod 644 {} \\;" "Setting 644 permissions for configuration files"

# Shell scripts
execute_cmd "find \"$TARGET_DIR\" -name \"*.sh\" -type f -exec chmod 755 {} \\;" "Setting 755 permissions for shell scripts"

# Log files
execute_cmd "find \"$TARGET_DIR\" -name \"*.log\" -type f -exec chmod 644 {} \\;" "Setting 644 permissions for log files"

# Private key files
execute_cmd "find \"$TARGET_DIR\" -name \"*.key\" -o -name \"*_rsa\" -o -name \"id_*\" -type f -exec chmod 600 {} \\;" "Setting 600 permissions for private key files"

log_message "Permission remediation completed"
echo "Permission remediation completed. Results saved to $LOG_FILE"

exit 0
```

### Script 3: Permission Template Applier

This script applies predefined permission templates to different types of applications:

```shellscript
#!/bin/bash
#
# apply_permission_template.sh - Apply predefined permission templates
# Usage: ./apply_permission_template.sh --template=<template> --target=<directory>

# Available templates:
# - web: Standard web server permissions
# - app: Application server permissions
# - shared: Shared directory permissions
# - secure: Highly secure permissions

# Logging setup
LOG_FILE="permission_template_$(date +%Y%m%d).log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Logging function
log_message() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Parse arguments
TEMPLATE=""
TARGET_DIR=""

for arg in "$@"; do
    case $arg in
        --template=*)
        TEMPLATE="${arg#*=}"
        shift
        ;;
        --target=*)
        TARGET_DIR="${arg#*=}"
        shift
        ;;
        --help)
        echo "Usage: $0 --template=<template> --target=<directory>"
        echo ""
        echo "Available templates:"
        echo "  - web: Standard web server permissions"
        echo "  - app: Application server permissions"
        echo "  - shared: Shared directory permissions"
        echo "  - secure: Highly secure permissions"
        exit 0
        ;;
    esac
done

# Validate arguments
if [[ -z "$TEMPLATE" || -z "$TARGET_DIR" ]]; then
    echo "Error: Both template and target directory must be specified"
    echo "Usage: $0 --template=<template> --target=<directory>"
    exit 1
fi

if [[ ! -d "$TARGET_DIR" ]]; then
    handle_error "$TARGET_DIR is not a directory"
fi

# Check if template is valid
case $TEMPLATE in
    web|app|shared|secure)
        # Valid template
        ;;
    *)
        handle_error "Invalid template: $TEMPLATE. Use --help to see available templates."
        ;;
esac

log_message "Applying $TEMPLATE permission template to $TARGET_DIR"

# Function to apply web server template
apply_web_template() {
    local target="$1"
    local web_user="www-data"  # Default for Debian/Ubuntu
    
    # Check if we're on RHEL/CentOS
    if id -u apache &>/dev/null; then
        web_user="apache"
    fi
    
    log_message "Using web server user: $web_user"
    
    # Set ownership
    chown -R $web_user:$web_user "$target"
    log_message "Set ownership to $web_user:$web_user"
    
    # Set directory permissions
    find "$target" -type d -exec chmod 755 {} \;
    log_message "Set directory permissions to 755"
    
    # Set file permissions
    find "$target" -type f -exec chmod 644 {} \;
    log_message "Set file permissions to 644"
    
    # Make specific directories writable for uploads
    for upload_dir in "$target/uploads" "$target/media" "$target/cache" "$target/tmp"; do
        if [[ -d "$upload_dir" ]]; then
            chmod 775 "$upload_dir"
            log_message "Set writable permissions (775) for $upload_dir"
        fi
    done
    
    # Set appropriate permissions for PHP files
    find "$target" -name "*.php" -exec chmod 644 {} \;
    log_message "Set PHP file permissions to 644"
    
    # Set appropriate permissions for configuration files
    find "$target" -name "*.conf" -o -name "*.config" -o -name "*.ini" -exec chmod 640 {} \;
    log_message "Set configuration file permissions to 640"
    
    log_message "Web server template applied successfully"
}

# Function to apply application server template
apply_app_template() {
    local target="$1"
    local app_user="app"
    local app_group="app"
    
    # Prompt for app user and group
    read -p "Enter application user [app]: " input_user
    read -p "Enter application group [app]: " input_group
    
    if [[ -n "$input_user" ]]; then
        app_user="$input_user"
    fi
    
    if [[ -n "$input_group" ]]; then
        app_group="$input_group"
    fi
    
    # Check if user exists, create if not
    if ! id -u "$app_user" &>/dev/null; then
        log_message "User $app_user does not exist, creating..."
        useradd -m "$app_user"
    fi
    
    # Check if group exists, create if not
    if ! getent group "$app_group" &>/dev/null; then
        log_message "Group $app_group does not exist, creating..."
        groupadd "$app_group"
    fi
    
    # Set ownership
    chown -R $app_user:$app_group "$target"
    log_message "Set ownership to $app_user:$app_group"
    
    # Set directory permissions
    find "$target" -type d -exec chmod 750 {} \;
    log_message "Set directory permissions to 750"
    
    # Set file permissions
    find "$target" -type f -exec chmod 640 {} \;
    log_message "Set file permissions to 640"
    
    # Make scripts executable
    find "$target" -name "*.sh" -o -name "*.py" -o -name "*.pl" -exec chmod 750 {} \;
    log_message "Set executable permissions (750) for scripts"
    
    # Set appropriate permissions for configuration files
    find "$target" -name "*.conf" -o -name "*.config" -o -name "*.ini" -o -name "*.json" -o -name "*.yml" -exec chmod 640 {} \;
    log_message "Set configuration file permissions to 640"
    
    # Set appropriate permissions for log files
    find "$target" -name "*.log" -exec chmod 660 {} \;
    log_message "Set log file permissions to 660"
    
    # Create log directory if it doesn't exist
    if [[ ! -d "$target/logs" ]]; then
        mkdir -p "$target/logs"
        chown $app_user:$app_group "$target/logs"
        chmod 770 "$target/logs"
        log_message "Created logs directory with permissions 770"
    fi
    
    log_message "Application server template applied successfully"
}

# Function to apply shared directory template
apply_shared_template() {
    local target="$1"
    local shared_group="shared"
    
    # Prompt for shared group
    read -p "Enter shared group name [shared]: " input_group
    
    if [[ -n "$input_group" ]]; then
        shared_group="$input_group"
    fi
    
    # Check if group exists, create if not
    if ! getent group "$shared_group" &>/dev/null; then
        log_message "Group $shared_group does not exist, creating..."
        groupadd "$shared_group"
    fi
    
    # Set ownership
    chown root:$shared_group "$target"
    log_message "Set ownership to root:$shared_group"
    
    # Set directory permissions with SGID to maintain group ownership
    chmod 2775 "$target"
    log_message "Set directory permissions to 2775 (SGID)"
    
    # Set SGID on all subdirectories
    find "$target" -type d -exec chmod 2775 {} \;
    log_message "Set SGID on all subdirectories"
    
    # Set file permissions
    find "$target" -type f -exec chmod 664 {} \;
    log_message "Set file permissions to 664"
    
    # Set default ACLs if getfacl/setfacl are available
    if command -v setfacl &> /dev/null; then
        setfacl -d -m g:$shared_group:rwx "$target"
        log_message "Set default ACLs for new files"
    else
        log_message "setfacl not available, skipping ACL setup"
    fi
    
    log_message "Shared directory template applied successfully"
}

# Function to apply secure template
apply_secure_template() {
    local target="$1"
    local secure_user="secure"
    local secure_group="secure"
    
    # Prompt for secure user and group
    read -p "Enter secure user [secure]: " input_user
    read -p "Enter secure group [secure]: " input_group
    
    if [[ -n "$input_user" ]]; then
        secure_user="$input_user"
    fi
    
    if [[ -n "$input_group" ]]; then
        secure_group="$input_group"
    fi
    
    # Check if user exists, create if not
    if ! id -u "$secure_user" &>/dev/null; then
        log_message "User $secure_user does not exist, creating..."
        useradd -m "$secure_user"
    fi
    
    # Check if group exists, create if not
    if ! getent group "$secure_group" &>/dev/null; then
        log_message "Group $secure_group does not exist, creating..."
        groupadd "$secure_group"
    fi
    
    # Set ownership
    chown -R $secure_user:$secure_group "$target"
    log_message "Set ownership to $secure_user:$secure_group"
    
    # Set directory permissions
    find "$target" -type d -exec chmod 700 {} \;
    log_message "Set directory permissions to 700"
    
    # Set file permissions
    find "$target" -type f -exec chmod 600 {} \;
    log_message "Set file permissions to 600"
    
    # Make scripts executable only by owner
    find "$target" -name "*.sh" -o -name "*.py" -o -name "*.pl" -exec chmod 700 {} \;
    log_message "Set executable permissions (700) for scripts"
    
    # Set appropriate permissions for sensitive files
    find "$target" -name "*.key" -o -name "*.pem" -o -name "*id_rsa*" -o -name "*.crt" -exec chmod 600 {} \;
    log_message "Set sensitive file permissions to 600"
    
    log_message "Secure template applied successfully"
}

# Apply the selected template
case $TEMPLATE in
    web)
        apply_web_template "$TARGET_DIR"
        ;;
    app)
        apply_app_template "$TARGET_DIR"
        ;;
    shared)
        apply_shared_template "$TARGET_DIR"
        ;;
    secure)
        apply_secure_template "$TARGET_DIR"
        ;;
esac

log_message "Permission template application completed"
echo "Permission template application completed. Results saved to $LOG_FILE"

exit 0
```

## Part 7: Best Practices for Permission Management

### General Permission Best Practices

1. **Follow the Principle of Least Privilege**

1. Grant only the permissions necessary for the task
2. Regularly audit and remove unnecessary permissions



2. **Use Groups Effectively**

1. Create functional groups based on access needs
2. Assign permissions to groups rather than individual users
3. Keep group memberships up to date



3. **Standardize Permission Schemes**

1. Develop standard permission templates for different types of files
2. Document your permission standards
3. Use automation to maintain consistency



4. **Secure Default Permissions**

1. Set a restrictive umask (e.g., 027 or 077)
2. Configure secure defaults in /etc/login.defs
3. Use PAM to enforce permission policies



5. **Regular Permission Audits**

1. Schedule regular permission audits
2. Use automated tools to identify issues
3. Document and remediate findings





### Specific Permission Recommendations

1. **System Files and Directories**

1. `/etc`: 755 for directories, 644 for files, owned by root:root
2. `/var/log`: 755 for directories, 640 for files, appropriate service ownership
3. `/home`: 755 for the directory, 700 for user home directories



2. **Web Server Files**

1. Web content: 644 for files, 755 for directories
2. Configuration: 640 for files, owned by root:web-server-group
3. Logs: 640 or 660, owned by web-server-user:web-server-group



3. **Application Files**

1. Binaries: 755, owned by root:root
2. Configuration: 640, owned by app-user:app-group
3. Data: 660, owned by app-user:app-group
4. Logs: 660, owned by app-user:app-group



4. **Database Files**

1. Data files: 600, owned by db-user:db-group
2. Configuration: 640, owned by db-user:db-group
3. Logs: 640, owned by db-user:db-group



5. **SSH and Cryptographic Files**

1. Private keys: 600, owned by the user
2. Public keys: 644
3. Known hosts: 644
4. SSH configuration: 600 for client, 644 for server





## Part 8: Troubleshooting Permission Issues

### Common Permission Problems and Solutions

1. **"Permission Denied" Errors**

Possible causes:

1. Insufficient file permissions
2. Incorrect ownership
3. Missing execute permission on parent directories
4. SELinux or AppArmor restrictions


Troubleshooting steps:

```shellscript
# Check file permissions and ownership
ls -la /path/to/file

# Check parent directory permissions
namei -l /path/to/file

# Check if SELinux is blocking access
ausearch -m avc -ts recent

# Check effective permissions for a user
sudo -u username ls -la /path/to/file
```


2. **Cannot Delete Files in a Directory**

Possible causes:

1. Missing write permission on the directory
2. Sticky bit set and not the file owner
3. Immutable flag set on the file


Troubleshooting steps:

```shellscript
# Check directory permissions
ls -ld /path/to/directory

# Check file ownership
ls -la /path/to/directory/file

# Check for immutable flag
lsattr /path/to/directory/file

# Remove immutable flag if present
chattr -i /path/to/directory/file
```


3. **Cannot Execute a Script**

Possible causes:

1. Missing execute permission
2. Incorrect shebang line
3. Script on a filesystem mounted with noexec


Troubleshooting steps:

```shellscript
# Check execute permission
ls -la script.sh

# Add execute permission if needed
chmod +x script.sh

# Check shebang line
head -n 1 script.sh

# Check if filesystem is mounted with noexec
mount | grep noexec
```


4. **Cannot Access Files with Correct Permissions**

Possible causes:

1. Missing execute permission on parent directories
2. ACLs restricting access
3. Mandatory Access Control (MAC) systems like SELinux


Troubleshooting steps:

```shellscript
# Check parent directory permissions
namei -l /path/to/file

# Check for ACLs
getfacl /path/to/file

# Check SELinux context
ls -Z /path/to/file

# Temporarily disable SELinux to test
sudo setenforce 0
# Don't forget to re-enable: sudo setenforce 1
```




### Permission Debugging Tools

1. **namei**: Trace path and show permissions for each component

```shellscript
namei -l /path/to/file
```


2. **strace**: Trace system calls to see permission errors

```shellscript
strace -e open,access,stat command
```


3. **lsof**: List open files to see what a process can access

```shellscript
lsof -p process_id
```


4. **getfacl/setfacl**: View and modify ACLs

```shellscript
getfacl /path/to/file
```


5. **ausearch**: Search audit logs for permission denials

```shellscript
ausearch -m avc -ts recent
```


6. **lsattr/chattr**: View and modify file attributes

```shellscript
lsattr /path/to/file
```




## Part 9: Real-World Permission Scenarios

### Scenario 1: Secure Web Application Deployment

For a production web application with multiple developers and sensitive data:

```shellscript
# Create application group
groupadd webapp

# Add developers to the group
usermod -aG webapp developer1
usermod -aG webapp developer2

# Create directory structure
mkdir -p /var/www/app/{public,private,logs,config,cache}

# Set base ownership
chown -R root:webapp /var/www/app

# Set base permissions
chmod 755 /var/www/app
chmod 750 /var/www/app/private
chmod 770 /var/www/app/logs
chmod 750 /var/www/app/config
chmod 770 /var/www/app/cache

# Set web server user
web_user="www-data"  # Debian/Ubuntu
# web_user="apache"  # RHEL/CentOS

# Set public directory ownership
chown -R $web_user:webapp /var/www/app/public

# Set SGID bit on directories to maintain group ownership
find /var/www/app -type d -exec chmod g+s {} \;

# Set default ACLs for new files
setfacl -R -d -m g:webapp:rwX /var/www/app

# Set specific permissions for sensitive files
find /var/www/app/config -name "*.php" -exec chmod 640 {} \;
find /var/www/app/config -name "*.key" -exec chmod 600 {} \;

# Set up log rotation with proper permissions
cat > /etc/logrotate.d/webapp << EOF
/var/www/app/logs/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 660 $web_user webapp
    sharedscripts
    postrotate
        systemctl reload nginx
    endscript
}
EOF
```

### Scenario 2: Multi-User Development Environment

For a shared development environment with multiple teams:

```shellscript
# Create team groups
groupadd developers
groupadd designers
groupadd qa

# Create project directory
mkdir -p /projects/website

# Set base ownership and permissions
chown root:developers /projects/website
chmod 2775 /projects/website

# Create team directories
mkdir -p /projects/website/{code,design,tests}

# Set team-specific permissions
chown root:developers /projects/website/code
chown root:designers /projects/website/design
chown root:qa /projects/website/tests

# Set SGID on all directories
find /projects/website -type d -exec chmod 2775 {} \;

# Set default ACLs
setfacl -d -m g:developers:rwx /projects/website/code
setfacl -d -m g:designers:rwx /projects/website/design
setfacl -d -m g:qa:rwx /projects/website/tests

# Allow all teams read access to all directories
setfacl -R -m g:developers:r-x /projects/website/design
setfacl -R -m g:developers:r-x /projects/website/tests
setfacl -R -m g:designers:r-x /projects/website/code
setfacl -R -m g:designers:r-x /projects/website/tests
setfacl -R -m g:qa:r-x /projects/website/code
setfacl -R -m g:qa:r-x /projects/website/design

# Set up git repository with proper permissions
mkdir /projects/website/repo.git
cd /projects/website/repo.git
git init --bare
chown -R root:developers /projects/website/repo.git
chmod -R 775 /projects/website/repo.git
```

### Scenario 3: Secure Database Server

For a production database server with sensitive data:

```shellscript
# Create database user and group
groupadd dbadmin
useradd -g dbadmin -s /bin/bash -m dbuser

# Create directory structure
mkdir -p /var/db/{data,backup,logs,config}

# Set ownership
chown -R dbuser:dbadmin /var/db

# Set base permissions
chmod 750 /var/db
chmod 700 /var/db/data
chmod 750 /var/db/backup
chmod 750 /var/db/logs
chmod 750 /var/db/config

# Set specific file permissions
chmod 600 /var/db/config/*.conf
chmod 600 /var/db/data/*.db

# Set up backup script with proper permissions
cat > /var/db/scripts/backup.sh << EOF
#!/bin/bash
# Database backup script
timestamp=\$(date +%Y%m%d_%H%M%S)
cp -a /var/db/data /var/db/backup/data_\$timestamp
find /var/db/backup -type d -mtime +7 -exec rm -rf {} \;
EOF

chmod 700 /var/db/scripts/backup.sh
chown dbuser:dbadmin /var/db/scripts/backup.sh

# Set up cron job for the backup
echo "0 2 * * * dbuser /var/db/scripts/backup.sh" > /etc/cron.d/db-backup
chmod 644 /etc/cron.d/db-backup
```

## Part 10: Advanced Permission Topics

### Mandatory Access Control (MAC) Systems

Beyond traditional Unix permissions, many Linux distributions include MAC systems:

#### SELinux (Security-Enhanced Linux)

SELinux adds context-based security policies:

```shellscript
# Check SELinux status
sestatus

# View file context
ls -Z /path/to/file

# Change file context
chcon -t httpd_sys_content_t /var/www/html/file.html

# Set context permanently
semanage fcontext -a -t httpd_sys_content_t "/var/www/html(/.*)?"
restorecon -Rv /var/www/html

# Allow a specific permission
audit2allow -a -M mypolicy
semodule -i mypolicy.pp
```

#### AppArmor

AppArmor provides path-based access control:

```shellscript
# Check AppArmor status
aa-status

# View profile
cat /etc/apparmor.d/usr.sbin.nginx

# Put profile in complain mode for testing
aa-complain /usr/sbin/nginx

# Put profile in enforce mode
aa-enforce /usr/sbin/nginx

# Update profile based on logs
aa-logprof
```

### File Capabilities

Instead of using SUID, modern Linux systems support more granular capabilities:

```shellscript
# View capabilities
getcap /path/to/file

# Set capabilities
setcap cap_net_bind_service=+ep /usr/bin/nginx

# Remove capabilities
setcap -r /usr/bin/nginx

# Common capabilities:
# cap_net_bind_service: Bind to ports below 1024
# cap_sys_ptrace: Trace processes
# cap_sys_admin: Perform system administration tasks
```

### Immutable Files

Prevent files from being modified, even by root:

```shellscript
# Make a file immutable
chattr +i /etc/important-config.conf

# Check attributes
lsattr /etc/important-config.conf

# Remove immutable flag
chattr -i /etc/important-config.conf
```

### Access Control Lists (ACLs) for Network File Systems

When working with NFS or Samba, consider these special considerations:

```shellscript
# NFS exports with proper permissions
# /etc/exports
/shared    192.168.1.0/24(rw,sync,no_root_squash)
/public    *(ro,sync,all_squash,anonuid=65534,anongid=65534)

# Samba share with proper permissions
# /etc/samba/smb.conf
[shared]
    path = /shared
    valid users = @shared_group
    read only = no
    create mask = 0660
    directory mask = 0770
    force group = shared_group
```

## Part 11: Resources for Further Learning

### Books and Documentation

1. **"Linux Security Cookbook"** by Daniel J. Barrett, Richard E. Silverman, and Robert G. Byrnes
2. **"Practical Linux Security Cookbook"** by Tajinder Kalsi
3. **"The Linux Command Line"** by William Shotts (Chapter on Permissions)
4. **"Linux Administration Handbook"** by Evi Nemeth et al.


### Online Resources

1. **Linux Documentation Project**: [https://tldp.org/HOWTO/Security-HOWTO/](https://tldp.org/HOWTO/Security-HOWTO/)
2. **Red Hat Security Guide**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/)
3. **Ubuntu Security Documentation**: [https://ubuntu.com/security](https://ubuntu.com/security)
4. **Linux Permissions Primer**: [https://www.digitalocean.com/community/tutorials/linux-permissions-basics-and-how-to-use-umask-on-a-vps](https://www.digitalocean.com/community/tutorials/linux-permissions-basics-and-how-to-use-umask-on-a-vps)


## Conclusion: Building a Secure Foundation

File permissions and ownership form the foundation of Linux security. By mastering these concepts, you've gained the ability to:

1. **Protect sensitive data** from unauthorized access
2. **Isolate services** to minimize the impact of security breaches
3. **Enable collaboration** while maintaining security boundaries
4. **Troubleshoot permission-related issues** effectively
5. **Automate permission management** for consistency and efficiency


Remember these key principles:

1. **Least Privilege**: Grant only the permissions necessary
2. **Defense in Depth**: Use multiple layers of protection
3. **Consistency**: Standardize your permission schemes
4. **Automation**: Use scripts to maintain and audit permissions
5. **Documentation**: Keep track of your permission policies


As you progress through this 30-day Linux Engineer Training Series, you'll build on this foundation to create increasingly sophisticated systems. The file permission and ownership skills you've learned today will serve as building blocks for everything from service configuration to container orchestration.

Tomorrow, we'll explore process management and monitoring, building on the security concepts we've covered so far. This will complete your understanding of the core Linux operational model and prepare you for more advanced topics.

Happy permission setting!
