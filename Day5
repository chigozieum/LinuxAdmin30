### Day 5: Managing Services with systemd - The Complete Guide

## Introduction: The Service Management Foundation

Welcome to Day 5 of our Linux Engineer Training Series! In the previous days, we've covered user management, file permissions, and package installation. Now it's time to bring your Linux systems to life by mastering service management with systemd.

Systemd has become the standard init system and service manager for most modern Linux distributions. It's responsible for initializing the system during the boot process and managing services throughout the system's runtime. Understanding systemd is crucial for any Linux engineer, as it's the backbone of service control, monitoring, and automation.

### Why Systemd Matters

Before diving into the technical details, let's understand why mastering systemd is essential for a Linux engineer:

- **Service Lifecycle Management**: Start, stop, restart, and monitor services with precision
- **Boot Process Control**: Manage what starts during system initialization and in what order
- **Dependency Management**: Ensure services start only when their dependencies are available
- **Resource Control**: Limit CPU, memory, and other resources for services
- **Logging Integration**: Centralized logging for all systemd-managed services
- **Security Enhancements**: Run services with minimal privileges and isolation
- **Automation**: Schedule services to run at specific times or intervals
- **Standardization**: Consistent management interface across different Linux distributions


Whether you're running web servers, databases, containerization platforms, or custom applications, systemd provides the tools to ensure they run reliably and efficiently.

## Part 1: Understanding Systemd Architecture

### The Evolution of Init Systems

To appreciate systemd, it helps to understand its predecessors:

1. **SysV Init**: The traditional Unix init system with numbered runlevels and shell scripts
2. **Upstart**: Event-based init system developed by Ubuntu
3. **Systemd**: Modern, dependency-based init system now used by most major distributions


Systemd was designed to overcome limitations of previous init systems, particularly:

- Parallel service startup for faster boot times
- On-demand service activation
- Automatic dependency handling
- Consistent service management across distributions


### Systemd Components

Systemd is not just a single program but a suite of components:

1. **systemd (PID 1)**: The core process that initializes the system
2. **systemctl**: Command-line tool for controlling systemd and managing services
3. **journald**: Logging system that collects and stores logs
4. **logind**: User login management
5. **networkd**: Network configuration management
6. **resolved**: DNS resolution
7. **timesyncd**: Time synchronization
8. **udevd**: Device management


### Unit Types

Systemd manages various types of "units," not just services:

1. **Service Units (.service)**: Daemons/processes that can be started, stopped, restarted
2. **Socket Units (.socket)**: IPC or network sockets for socket activation
3. **Target Units (.target)**: Groups of units (replacement for runlevels)
4. **Mount Units (.mount)**: File system mount points
5. **Timer Units (.timer)**: Scheduled tasks (replacement for cron jobs)
6. **Path Units (.path)**: File system path monitoring
7. **Slice Units (.slice)**: Resource control groups
8. **Scope Units (.scope)**: Externally created processes
9. **Device Units (.device)**: Hardware devices
10. **Swap Units (.swap)**: Swap partitions or files


### Systemd Directory Structure

Systemd unit files are stored in several locations, with a specific precedence order:

1. **/usr/lib/systemd/system/**: Units provided by installed packages
2. **/etc/systemd/system/**: Units created by system administrators (overrides the above)
3. **/run/systemd/system/**: Runtime units
4. **~/.config/systemd/user/**: User units


When multiple unit files with the same name exist in different locations, the one with higher precedence (lower number in the list above) takes effect.

## Part 2: Essential Systemd Service Management

### Basic Service Control Commands

```shellscript
# Start a service
systemctl start nginx.service

# Stop a service
systemctl stop nginx.service

# Restart a service
systemctl restart nginx.service

# Reload a service's configuration without restarting
systemctl reload nginx.service

# Reload-or-restart (reload if supported, otherwise restart)
systemctl reload-or-restart nginx.service

# Check the status of a service
systemctl status nginx.service

# Enable a service to start at boot
systemctl enable nginx.service

# Disable a service from starting at boot
systemctl disable nginx.service

# Check if a service is enabled
systemctl is-enabled nginx.service

# Mask a service (prevent it from being started)
systemctl mask nginx.service

# Unmask a service
systemctl unmask nginx.service
```

Note: The `.service` suffix is optional in most commands but can help avoid ambiguity with other unit types.

### Viewing Service Information

```shellscript
# List all active services
systemctl list-units --type=service

# List all services (including inactive)
systemctl list-units --type=service --all

# List failed services
systemctl --failed

# List all service files
systemctl list-unit-files --type=service

# Show detailed information about a service
systemctl show nginx.service

# Show dependencies of a service
systemctl list-dependencies nginx.service

# Show properties of a service
systemctl show -p Requires,Wants nginx.service
```

### Managing Service Boot Behavior

```shellscript
# Enable a service to start at boot
systemctl enable nginx.service

# Enable and immediately start a service
systemctl enable --now nginx.service

# Disable a service from starting at boot
systemctl disable nginx.service

# Disable and immediately stop a service
systemctl disable --now nginx.service

# Check if a service starts automatically at boot
systemctl is-enabled nginx.service
```

### Service States

A service can be in one of several states:

- **active (running)**: The service is running with one or more processes
- **active (exited)**: The service completed a one-time task successfully
- **active (waiting)**: The service is running but waiting for an event
- **inactive**: The service is not running
- **failed**: The service failed to start or crashed
- **activating**: The service is in the process of starting
- **deactivating**: The service is in the process of stopping


### Viewing Service Logs

```shellscript
# View logs for a specific service
journalctl -u nginx.service

# Follow logs in real-time (like tail -f)
journalctl -u nginx.service -f

# View logs since the last boot
journalctl -u nginx.service -b

# View logs with specific priority (emerg, alert, crit, err, warning, notice, info, debug)
journalctl -u nginx.service -p err

# View logs within a time range
journalctl -u nginx.service --since "2023-05-01" --until "2023-05-02 12:00:00"

# View logs with context (shows explanations for errors)
journalctl -u nginx.service -x
```

## Part 3: Creating and Configuring Custom Systemd Services

### Anatomy of a Service Unit File

A systemd service unit file consists of several sections:

1. **[Unit]**: General information about the unit, including description and dependencies
2. **[Service]**: Service-specific configuration
3. **[Install]**: Information used when enabling/disabling the service


Here's a basic example:

```ini
[Unit]
Description=My Custom Service
After=network.target
Requires=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/my-service --option=value
Restart=on-failure
RestartSec=5
User=serviceuser
Group=servicegroup

[Install]
WantedBy=multi-user.target
```

### Creating a Basic Service

Let's create a simple service that runs a Python script:

```shellscript
# Create the service file
sudo nano /etc/systemd/system/myapp.service
```

```ini
[Unit]
Description=My Python Application
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /opt/myapp/app.py
WorkingDirectory=/opt/myapp
Restart=always
RestartSec=10
User=myappuser
Group=myappgroup
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
```

After creating or modifying a service file, you need to reload the systemd manager:

```shellscript
# Reload systemd manager configuration
sudo systemctl daemon-reload

# Enable and start the service
sudo systemctl enable --now myapp.service
```

### Service Types

The `Type=` directive in the `[Service]` section defines how systemd considers the service started:

- **simple**: Default type. The main process of the service is the process started with ExecStart
- **forking**: The process started with ExecStart spawns a child process that becomes the main service process
- **oneshot**: The process exits before starting follow-up units
- **dbus**: The service is considered ready when it acquires a name on the D-Bus
- **notify**: The service sends a notification when it's ready
- **idle**: Similar to simple, but the service is started after all jobs are dispatched


### Important Service Directives

Here are some important directives for the `[Service]` section:

```ini
[Service]
# Command to execute when starting the service
ExecStart=/path/to/executable

# Commands to execute before starting the service
ExecStartPre=/path/to/pre-start-script

# Commands to execute after starting the service
ExecStartPost=/path/to/post-start-script

# Command to execute when stopping the service
ExecStop=/path/to/stop-script

# Command to execute when reloading the service
ExecReload=/path/to/reload-script

# Working directory
WorkingDirectory=/path/to/working/directory

# User and group to run the service as
User=username
Group=groupname

# Restart policy (no, always, on-success, on-failure, on-abnormal, on-abort, on-watchdog)
Restart=on-failure

# Time to wait before restarting the service
RestartSec=5s

# Maximum number of restart attempts within a time interval
StartLimitIntervalSec=500s
StartLimitBurst=5

# Environment variables
Environment=VAR1=value1 VAR2=value2
EnvironmentFile=/path/to/env/file

# Process resource limits
LimitNOFILE=65535
LimitCPU=200
LimitAS=1G

# Timeout for starting the service
TimeoutStartSec=30s

# Timeout for stopping the service
TimeoutStopSec=30s

# Send SIGKILL if service doesn't stop after TimeoutStopSec
KillMode=process

# Signal to use when stopping the service
KillSignal=SIGTERM
```

### Service Dependencies

Systemd provides several directives to define dependencies between units:

```ini
[Unit]
# Units that must be started before this unit
After=network.target syslog.service

# Units that must be successfully activated before this unit
Requires=mysql.service

# Units that should be started before this unit, but are not required
Wants=redis.service

# Units that conflict with this unit
Conflicts=apache2.service

# This unit is bound to another unit's state (starts/stops together)
BindsTo=another.service

# Units that should be started when this unit fails
OnFailure=alert-admin.service
```

## Part 4: Advanced Systemd Features

### Systemd Targets (Replacement for Runlevels)

Targets are groups of units that provide a way to bring the system to a specific state. They replace the traditional SysV runlevels.

Common targets include:

- **poweroff.target**: Shutdown the system
- **rescue.target**: Single-user mode (similar to runlevel 1)
- **multi-user.target**: Multi-user text mode (similar to runlevel 3)
- **graphical.target**: Multi-user graphical mode (similar to runlevel 5)
- **reboot.target**: Reboot the system


```shellscript
# View the default target
systemctl get-default

# Set the default target
systemctl set-default multi-user.target

# Switch to a different target
systemctl isolate rescue.target

# List all available targets
systemctl list-units --type=target

# View dependencies of a target
systemctl list-dependencies multi-user.target
```

### Systemd Timers (Replacement for Cron)

Systemd timers provide a way to schedule tasks, similar to cron but with more features:

1. Create a service unit that performs the task:


```ini
# /etc/systemd/system/backup.service
[Unit]
Description=Daily Backup Service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup-script.sh
User=backupuser
```

2. Create a timer unit that activates the service:


```ini
# /etc/systemd/system/backup.timer
[Unit]
Description=Run backup daily

[Timer]
OnCalendar=*-*-* 02:00:00
Persistent=true
Unit=backup.service

[Install]
WantedBy=timers.target
```

3. Enable and start the timer:


```shellscript
systemctl daemon-reload
systemctl enable backup.timer
systemctl start backup.timer
```

Timer scheduling options:

```ini
# Run once after boot, with a delay
OnBootSec=15min

# Run periodically after boot
OnUnitActiveSec=1h

# Run at specific calendar times
OnCalendar=Mon,Tue *-*-* 00:00:00
OnCalendar=*:0/15        # Every 15 minutes
OnCalendar=weekly        # Once a week

# Run when a specific file is modified
OnChangeSec=/path/to/file 1h
```

To list all active timers:

```shellscript
systemctl list-timers
```

### Systemd Socket Activation

Socket activation allows systemd to create listening sockets and pass them to services when needed, enabling on-demand service startup:

1. Create a socket unit:


```ini
# /etc/systemd/system/myapp.socket
[Unit]
Description=My App Socket

[Socket]
ListenStream=8080
Accept=no

[Install]
WantedBy=sockets.target
```

2. Create a corresponding service unit:


```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My App Service
Requires=myapp.socket
After=myapp.socket

[Service]
ExecStart=/usr/local/bin/myapp
StandardInput=socket
StandardError=journal

[Install]
WantedBy=multi-user.target
```

3. Enable and start the socket:


```shellscript
systemctl daemon-reload
systemctl enable myapp.socket
systemctl start myapp.socket
```

The service will start automatically when a connection is made to the socket.

### Resource Control with Systemd

Systemd provides resource control capabilities through cgroups:

```ini
[Service]
# CPU limits
CPUQuota=20%
CPUWeight=100

# Memory limits
MemoryLimit=1G
MemoryHigh=800M
MemoryMax=1G

# I/O limits
IOWeight=100
IODeviceWeight=/dev/sda 500
IOReadBandwidthMax=/dev/sda 50M
IOWriteBandwidthMax=/dev/sda 50M

# Tasks/processes limits
TasksMax=100
```

To apply resource limits to a running service:

```shellscript
# Set CPU quota for a service
systemctl set-property myapp.service CPUQuota=20%

# Set memory limit for a service
systemctl set-property myapp.service MemoryLimit=1G
```

## Part 5: Comprehensive Systemd Management Scripts

### Script 1: Service Manager

This script provides a comprehensive interface for managing systemd services:

```shellscript
#!/bin/bash
#
# service_manager.sh - Comprehensive systemd service management
# Usage: ./service_manager.sh [service_name]

# Logging setup
LOG_FILE="service_manager_$(date +%Y%m%d).log"

# Logging function
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    handle_error "This script must be run as root"
fi

# Get service name from argument or prompt
if [[ $# -eq 1 ]]; then
    SERVICE="$1"
else
    read -p "Enter service name: " SERVICE
fi

# Validate service name
if [[ -z "$SERVICE" ]]; then
    handle_error "Service name cannot be empty"
fi

# Add .service suffix if not present
if [[ ! "$SERVICE" =~ \.service$ ]]; then
    SERVICE="${SERVICE}.service"
fi

# Check if service exists
if ! systemctl list-unit-files --type=service | grep -q "$SERVICE"; then
    handle_error "Service $SERVICE does not exist"
fi

# Function to display service status
show_status() {
    log_message "Checking status of $SERVICE"
    systemctl status "$SERVICE"
    
    echo ""
    echo "Additional Information:"
    echo "----------------------"
    
    # Check if service is enabled
    if systemctl is-enabled "$SERVICE" &>/dev/null; then
        echo "Service is enabled to start at boot"
    else
        echo "Service is NOT enabled to start at boot"
    fi
    
    # Check if service is active
    if systemctl is-active "$SERVICE" &>/dev/null; then
        echo "Service is currently active (running)"
    else
        echo "Service is currently inactive (not running)"
    fi
    
    # Show recent logs
    echo ""
    echo "Recent Logs:"
    echo "------------"
    journalctl -u "$SERVICE" --no-pager -n 10
}

# Function to start service
start_service() {
    log_message "Starting $SERVICE"
    if systemctl start "$SERVICE"; then
        log_message "$SERVICE started successfully"
        return 0
    else
        log_message "Failed to start $SERVICE"
        return 1
    fi
}

# Function to stop service
stop_service() {
    log_message "Stopping $SERVICE"
    if systemctl stop "$SERVICE"; then
        log_message "$SERVICE stopped successfully"
        return 0
    else
        log_message "Failed to stop $SERVICE"
        return 1
    fi
}

# Function to restart service
restart_service() {
    log_message "Restarting $SERVICE"
    if systemctl restart "$SERVICE"; then
        log_message "$SERVICE restarted successfully"
        return 0
    else
        log_message "Failed to restart $SERVICE"
        return 1
    fi
}

# Function to reload service
reload_service() {
    log_message "Reloading $SERVICE"
    if systemctl reload "$SERVICE" 2>/dev/null; then
        log_message "$SERVICE reloaded successfully"
        return 0
    else
        log_message "$SERVICE does not support reload, trying restart"
        restart_service
        return $?
    fi
}

# Function to enable service
enable_service() {
    log_message "Enabling $SERVICE"
    if systemctl enable "$SERVICE"; then
        log_message "$SERVICE enabled successfully"
        return 0
    else
        log_message "Failed to enable $SERVICE"
        return 1
    fi
}

# Function to disable service
disable_service() {
    log_message "Disabling $SERVICE"
    if systemctl disable "$SERVICE"; then
        log_message "$SERVICE disabled successfully"
        return 0
    else
        log_message "Failed to disable $SERVICE"
        return 1
    fi
}

# Function to view service logs
view_logs() {
    log_message "Viewing logs for $SERVICE"
    
    # Ask for number of lines
    read -p "Number of log lines to display [50]: " LINES
    LINES=${LINES:-50}
    
    # Ask for follow mode
    read -p "Follow logs in real-time? (y/n) [n]: " FOLLOW
    FOLLOW=${FOLLOW:-n}
    
    if [[ "$FOLLOW" =~ ^[Yy]$ ]]; then
        journalctl -u "$SERVICE" -n "$LINES" -f
    else
        journalctl -u "$SERVICE" -n "$LINES" --no-pager
    fi
}

# Function to edit service file
edit_service_file() {
    log_message "Editing service file for $SERVICE"
    
    # Find service file location
    SERVICE_FILE=$(systemctl show -p FragmentPath "$SERVICE" | cut -d= -f2)
    
    if [[ -z "$SERVICE_FILE" ]]; then
        log_message "Could not find service file for $SERVICE"
        return 1
    fi
    
    log_message "Service file located at: $SERVICE_FILE"
    
    # Check if file is editable (not in /usr)
    if [[ "$SERVICE_FILE" =~ ^/usr/ ]]; then
        log_message "Service file is in /usr, creating override instead"
        mkdir -p /etc/systemd/system/"$SERVICE".d
        
        # Create or edit override file
        OVERRIDE_FILE="/etc/systemd/system/${SERVICE}.d/override.conf"
        ${EDITOR:-nano} "$OVERRIDE_FILE"
        
        log_message "Override file edited: $OVERRIDE_FILE"
    else
        # Edit the service file directly
        ${EDITOR:-nano} "$SERVICE_FILE"
        log_message "Service file edited: $SERVICE_FILE"
    fi
    
    # Reload systemd configuration
    systemctl daemon-reload
    log_message "Systemd configuration reloaded"
    
    # Ask to restart the service
    read -p "Restart the service to apply changes? (y/n) [y]: " RESTART
    RESTART=${RESTART:-y}
    
    if [[ "$RESTART" =~ ^[Yy]$ ]]; then
        restart_service
    fi
}

# Function to create service override
create_override() {
    log_message "Creating override for $SERVICE"
    
    # Create override directory if it doesn't exist
    mkdir -p /etc/systemd/system/"$SERVICE".d
    
    # Create or edit override file
    OVERRIDE_FILE="/etc/systemd/system/${SERVICE}.d/override.conf"
    
    # Provide template
    cat > "$OVERRIDE_FILE" << EOF
# Override configuration for $SERVICE
# Uncomment and modify the directives you want to override

#[Service]
#ExecStart=
#ExecStart=/new/path/to/executable
#Environment=KEY=value
#Restart=always
#User=newuser

#[Unit]
#After=
#After=network.target
EOF
    
    # Open the file for editing
    ${EDITOR:-nano} "$OVERRIDE_FILE"
    
    log_message "Override file created/edited: $OVERRIDE_FILE"
    
    # Reload systemd configuration
    systemctl daemon-reload
    log_message "Systemd configuration reloaded"
    
    # Ask to restart the service
    read -p "Restart the service to apply changes? (y/n) [y]: " RESTART
    RESTART=${RESTART:-y}
    
    if [[ "$RESTART" =~ ^[Yy]$ ]]; then
        restart_service
    fi
}

# Function to show service dependencies
show_dependencies() {
    log_message "Showing dependencies for $SERVICE"
    echo "Dependencies for $SERVICE:"
    echo "-------------------------"
    systemctl list-dependencies "$SERVICE"
}

# Function to show service properties
show_properties() {
    log_message "Showing properties for $SERVICE"
    echo "Properties for $SERVICE:"
    echo "----------------------"
    systemctl show "$SERVICE"
}

# Main menu
while true; do
    echo ""
    echo "Service Manager - $SERVICE"
    echo "=========================="
    echo "1. Show Status"
    echo "2. Start Service"
    echo "3. Stop Service"
    echo "4. Restart Service"
    echo "5. Reload Service"
    echo "6. Enable Service"
    echo "7. Disable Service"
    echo "8. View Logs"
    echo "9. Edit Service File"
    echo "10. Create Override"
    echo "11. Show Dependencies"
    echo "12. Show Properties"
    echo "0. Exit"
    echo ""
    
    read -p "Enter your choice: " CHOICE
    
    case $CHOICE in
        1) show_status ;;
        2) start_service ;;
        3) stop_service ;;
        4) restart_service ;;
        5) reload_service ;;
        6) enable_service ;;
        7) disable_service ;;
        8) view_logs ;;
        9) edit_service_file ;;
        10) create_override ;;
        11) show_dependencies ;;
        12) show_properties ;;
        0) log_message "Exiting service manager"; exit 0 ;;
        *) echo "Invalid choice, please try again" ;;
    esac
    
    # Pause before showing menu again
    read -p "Press Enter to continue..."
done
```

### Script 2: Service Monitor

This script monitors the status of critical services and takes action if they fail:

```shellscript
#!/bin/bash
#
# service_monitor.sh - Monitor critical services and restart if needed
# Usage: ./service_monitor.sh [--config=/path/to/config] [--daemon]

# Default configuration file
CONFIG_FILE="/etc/service_monitor.conf"
DAEMON_MODE=false
LOG_FILE="/var/log/service_monitor.log"
ALERT_EMAIL=""
CHECK_INTERVAL=300  # 5 minutes

# Parse arguments
for arg in "$@"; do
    case $arg in
        --config=*)
        CONFIG_FILE="${arg#*=}"
        shift
        ;;
        --daemon)
        DAEMON_MODE=true
        shift
        ;;
    esac
done

# Logging function
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    handle_error "This script must be run as root"
fi

# Create default config if it doesn't exist
if [[ ! -f "$CONFIG_FILE" ]]; then
    log_message "Configuration file not found, creating default at $CONFIG_FILE"
    
    cat > "$CONFIG_FILE" << EOF
# Service Monitor Configuration
# Format: service_name:max_restarts:alert_on_failure

# Critical services
nginx.service:3:yes
mysql.service:3:yes
ssh.service:3:yes

# Important services
redis.service:5:no
memcached.service:5:no

# Email for alerts
alert_email=admin@example.com

# Check interval in seconds
check_interval=300
EOF
    
    log_message "Default configuration created. Please review and customize."
fi

# Load configuration
if [[ -f "$CONFIG_FILE" ]]; then
    log_message "Loading configuration from $CONFIG_FILE"
    
    # Load email and interval settings
    ALERT_EMAIL=$(grep "^alert_email=" "$CONFIG_FILE" | cut -d= -f2)
    CUSTOM_INTERVAL=$(grep "^check_interval=" "$CONFIG_FILE" | cut -d= -f2)
    
    if [[ -n "$CUSTOM_INTERVAL" ]] && [[ "$CUSTOM_INTERVAL" =~ ^[0-9]+$ ]]; then
        CHECK_INTERVAL=$CUSTOM_INTERVAL
    fi
    
    log_message "Check interval set to $CHECK_INTERVAL seconds"
    if [[ -n "$ALERT_EMAIL" ]]; then
        log_message "Alerts will be sent to $ALERT_EMAIL"
    else
        log_message "No alert email configured"
    fi
else
    handle_error "Configuration file not found: $CONFIG_FILE"
fi

# Function to check and restart services
check_services() {
    log_message "Checking services..."
    
    # Read services from config file
    grep -v "^#" "$CONFIG_FILE" | grep -v "^$" | grep -v "=" | while IFS=: read -r SERVICE MAX_RESTARTS ALERT; do
        # Skip empty lines
        if [[ -z "$SERVICE" ]]; then
            continue
        fi
        
        # Check if service exists
        if ! systemctl list-unit-files --type=service | grep -q "$SERVICE"; then
            log_message "Warning: Service $SERVICE does not exist, skipping"
            continue
        }
        
        # Check service status
        if ! systemctl is-active --quiet "$SERVICE"; then
            log_message "Service $SERVICE is not running"
            
            # Get restart count from temporary file
            RESTART_COUNT_FILE="/tmp/service_monitor_${SERVICE//\//_}.count"
            RESTART_COUNT=0
            
            if [[ -f "$RESTART_COUNT_FILE" ]]; then
                RESTART_COUNT=$(cat "$RESTART_COUNT_FILE")
            fi
            
            # Check if we've reached the maximum restart attempts
            if [[ $RESTART_COUNT -lt $MAX_RESTARTS ]]; then
                log_message "Attempting to restart $SERVICE (attempt $((RESTART_COUNT+1))/$MAX_RESTARTS)"
                
                if systemctl restart "$SERVICE"; then
                    log_message "Successfully restarted $SERVICE"
                    
                    # Increment restart count
                    echo $((RESTART_COUNT+1)) > "$RESTART_COUNT_FILE"
                    
                    # Send alert if configured
                    if [[ "$ALERT" == "yes" ]] && [[ -n "$ALERT_EMAIL" ]]; then
                        echo "Service $SERVICE was down and has been restarted (attempt $((RESTART_COUNT+1))/$MAX_RESTARTS)." | \
                        mail -s "Service Restarted: $SERVICE on $(hostname)" "$ALERT_EMAIL"
                    fi
                else
                    log_message "Failed to restart $SERVICE"
                    
                    # Send alert if configured
                    if [[ "$ALERT" == "yes" ]] && [[ -n "$ALERT_EMAIL" ]]; then
                        echo "Service $SERVICE is down and could not be restarted. Manual intervention required." | \
                        mail -s "Service Failure: $SERVICE on $(hostname)" "$ALERT_EMAIL"
                    fi
                fi
            else
                log_message "Maximum restart attempts ($MAX_RESTARTS) reached for $SERVICE, manual intervention required"
                
                # Send alert if configured
                if [[ "$ALERT" == "yes" ]] && [[ -n "$ALERT_EMAIL" ]]; then
                    echo "Service $SERVICE is down and has reached the maximum restart attempts ($MAX_RESTARTS). Manual intervention required." | \
                    mail -s "Service Failure: $SERVICE on $(hostname)" "$ALERT_EMAIL"
                fi
            fi
        else
            # Service is running, reset restart count
            if [[ -f "/tmp/service_monitor_${SERVICE//\//_}.count" ]]; then
                rm "/tmp/service_monitor_${SERVICE//\//_}.count"
            fi
        fi
    done
    
    log_message "Service check completed"
}

# Run in daemon mode if requested
if [[ "$DAEMON_MODE" == true ]]; then
    log_message "Starting in daemon mode with interval of $CHECK_INTERVAL seconds"
    
    while true; do
        check_services
        sleep "$CHECK_INTERVAL"
    done
else
    # Run once
    check_services
fi

exit 0
```

### Script 3: Service Creator

This script helps create new systemd service files:

```shellscript
#!/bin/bash
#
# service_creator.sh - Create systemd service files
# Usage: ./service_creator.sh

# Logging setup
LOG_FILE="service_creator_$(date +%Y%m%d).log"

# Logging function
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Error handler
handle_error() {
    log_message "ERROR: $1"
    exit 1
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    handle_error "This script must be run as root"
fi

log_message "Starting service creator"

# Function to get valid input
get_valid_input() {
    local prompt="$1"
    local var_name="$2"
    local default="$3"
    local allow_empty="$4"
    
    while true; do
        read -p "$prompt" input
        
        # Use default if input is empty
        if [[ -z "$input" && -n "$default" ]]; then
            eval "$var_name='$default'"
            break
        elif [[ -z "$input" && "$allow_empty" == "yes" ]]; then
            eval "$var_name=''"
            break
        elif [[ -z "$input" ]]; then
            echo "Input cannot be empty. Please try again."
        else
            eval "$var_name='$input'"
            break
        fi
    done
}

# Get service information
echo "Systemd Service Creator"
echo "======================="
echo "This script will help you create a systemd service file."
echo ""

# Get service name
get_valid_input "Service name (without .service suffix): " SERVICE_NAME

# Validate service name
if [[ ! "$SERVICE_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    handle_error "Invalid service name. Use only letters, numbers, underscores, and hyphens."
fi

# Check if service already exists
if systemctl list-unit-files --type=service | grep -q "$SERVICE_NAME.service"; then
    read -p "Service $SERVICE_NAME already exists. Overwrite? (y/n) [n]: " OVERWRITE
    OVERWRITE=${OVERWRITE:-n}
    
    if [[ ! "$OVERWRITE" =~ ^[Yy]$ ]]; then
        handle_error "Operation cancelled"
    fi
fi

# Get service description
get_valid_input "Description: " DESCRIPTION "Service for $SERVICE_NAME"

# Get executable path
get_valid_input "Executable path (full path to the program): " EXEC_START

# Validate executable path
if [[ ! -f "$EXEC_START" && ! "$EXEC_START" =~ ^/ ]]; then
    echo "Warning: Executable path does not exist or is not an absolute path."
    read -p "Continue anyway? (y/n) [n]: " CONTINUE
    CONTINUE=${CONTINUE:-n}
    
    if [[ ! "$CONTINUE" =~ ^[Yy]$ ]]; then
        handle_error "Operation cancelled"
    fi
fi

# Get working directory
get_valid_input "Working directory [/]: " WORKING_DIR "/" "yes"

# Get user to run as
get_valid_input "User to run as [root]: " SERVICE_USER "root" "yes"

# Get group to run as
get_valid_input "Group to run as [root]: " SERVICE_GROUP "root" "yes"

# Get restart policy
echo "Restart policy options:"
echo "1. no - Do not restart"
echo "2. always - Always restart"
echo "3. on-success - Restart only on successful exit"
echo "4. on-failure - Restart only on failure"
echo "5. on-abnormal - Restart on failure, TERM signal, or timeout"
echo "6. on-abort - Restart on uncaught signal"
echo "7. on-watchdog - Restart on watchdog timeout"
read -p "Select restart policy [4]: " RESTART_OPTION
RESTART_OPTION=${RESTART_OPTION:-4}

case $RESTART_OPTION in
    1) RESTART="no" ;;
    2) RESTART="always" ;;
    3) RESTART="on-success" ;;
    4) RESTART="on-failure" ;;
    5) RESTART="on-abnormal" ;;
    6) RESTART="on-abort" ;;
    7) RESTART="on-watchdog" ;;
    *) RESTART="on-failure" ;;
esac

# Get restart delay
get_valid_input "Restart delay in seconds [5]: " RESTART_SEC "5" "yes"

# Get dependencies
get_valid_input "After dependencies (space-separated, e.g., network.target syslog.service): " AFTER "network.target" "yes"

# Get required dependencies
get_valid_input "Required dependencies (space-separated): " REQUIRES "" "yes"

# Get wanted dependencies
get_valid_input "Wanted dependencies (space-separated): " WANTS "" "yes"

# Get target for installation
echo "Installation target options:"
echo "1. multi-user.target - Normal system startup"
echo "2. graphical.target - Graphical system startup"
echo "3. network.target - Network is up"
echo "4. basic.target - Basic system startup"
echo "5. custom target"
read -p "Select installation target [1]: " TARGET_OPTION
TARGET_OPTION=${TARGET_OPTION:-1}

case $TARGET_OPTION in
    1) WANTED_BY="multi-user.target" ;;
    2) WANTED_BY="graphical.target" ;;
    3) WANTED_BY="network.target" ;;
    4) WANTED_BY="basic.target" ;;
    5) get_valid_input "Enter custom target: " WANTED_BY ;;
    *) WANTED_BY="multi-user.target" ;;
esac

# Ask for environment variables
read -p "Add environment variables? (y/n) [n]: " ADD_ENV
ADD_ENV=${ADD_ENV:-n}

ENV_VARS=""
if [[ "$ADD_ENV" =~ ^[Yy]$ ]]; then
    echo "Enter environment variables (KEY=VALUE), one per line. Empty line to finish."
    while true; do
        read -p "ENV: " ENV_VAR
        if [[ -z "$ENV_VAR" ]]; then
            break
        fi
        ENV_VARS="${ENV_VARS}Environment=${ENV_VAR}\n"
    done
fi

# Ask for additional options
read -p "Add additional options? (y/n) [n]: " ADD_OPTIONS
ADD_OPTIONS=${ADD_OPTIONS:-n}

ADDITIONAL_OPTIONS=""
if [[ "$ADD_OPTIONS" =~ ^[Yy]$ ]]; then
    echo "Select additional options:"
    
    read -p "Set timeout for service start (seconds, empty to skip): " TIMEOUT_START
    if [[ -n "$TIMEOUT_START" ]]; then
        ADDITIONAL_OPTIONS="${ADDITIONAL_OPTIONS}TimeoutStartSec=${TIMEOUT_START}\n"
    fi
    
    read -p "Set timeout for service stop (seconds, empty to skip): " TIMEOUT_STOP
    if [[ -n "$TIMEOUT_STOP" ]]; then
        ADDITIONAL_OPTIONS="${ADDITIONAL_OPTIONS}TimeoutStopSec=${TIMEOUT_STOP}\n"
    fi
    
    read -p "Set maximum file descriptors (empty to skip): " LIMIT_NOFILE
    if [[ -n "$LIMIT_NOFILE" ]]; then
        ADDITIONAL_OPTIONS="${ADDITIONAL_OPTIONS}LimitNOFILE=${LIMIT_NOFILE}\n"
    fi
    
    read -p "Add StandardOutput (journal, syslog, file:path, null, empty to skip): " STD_OUT
    if [[ -n "$STD_OUT" ]]; then
        ADDITIONAL_OPTIONS="${ADDITIONAL_OPTIONS}StandardOutput=${STD_OUT}\n"
    fi
    
    read -p "Add StandardError (journal, syslog, file:path, null, empty to skip): " STD_ERR
    if [[ -n "$STD_ERR" ]]; then
        ADDITIONAL_OPTIONS="${ADDITIONAL_OPTIONS}StandardError=${STD_ERR}\n"
    fi
fi

# Create service file
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
log_message "Creating service file: $SERVICE_FILE"

cat > "$SERVICE_FILE" << EOF
[Unit]
Description=$DESCRIPTION
EOF

if [[ -n "$AFTER" ]]; then
    echo "After=$AFTER" >> "$SERVICE_FILE"
fi

if [[ -n "$REQUIRES" ]]; then
    echo "Requires=$REQUIRES" >> "$SERVICE_FILE"
fi

if [[ -n "$WANTS" ]]; then
    echo "Wants=$WANTS" >> "$SERVICE_FILE"
fi

cat >> "$SERVICE_FILE" << EOF

[Service]
Type=simple
ExecStart=$EXEC_START
EOF

if [[ -n "$WORKING_DIR" ]]; then
    echo "WorkingDirectory=$WORKING_DIR" >> "$SERVICE_FILE"
fi

if [[ -n "$SERVICE_USER" ]]; then
    echo "User=$SERVICE_USER" >> "$SERVICE_FILE"
fi

if [[ -n "$SERVICE_GROUP" ]]; then
    echo "Group=$SERVICE_GROUP" >> "$SERVICE_FILE"
fi

echo "Restart=$RESTART" >> "$SERVICE_FILE"
echo "RestartSec=$RESTART_SEC" >> "$SERVICE_FILE"

if [[ -n "$ENV_VARS" ]]; then
    echo -e "$ENV_VARS" >> "$SERVICE_FILE"
fi

if [[ -n "$ADDITIONAL_OPTIONS" ]]; then
    echo -e "$ADDITIONAL_OPTIONS" >> "$SERVICE_FILE"
fi

cat >> "$SERVICE_FILE" << EOF

[Install]
WantedBy=$WANTED_BY
EOF

log_message "Service file created successfully"

# Reload systemd
log_message "Reloading systemd configuration"
systemctl daemon-reload

# Ask to enable and start the service
read -p "Enable the service to start at boot? (y/n) [y]: " ENABLE
ENABLE=${ENABLE:-y}

if [[ "$ENABLE" =~ ^[Yy]$ ]]; then
    log_message "Enabling service $SERVICE_NAME"
    systemctl enable "$SERVICE_NAME.service"
fi

read -p "Start the service now? (y/n) [y]: " START
START=${START:-y}

if [[ "$START" =~ ^[Yy]$ ]]; then
    log_message "Starting service $SERVICE_NAME"
    systemctl start "$SERVICE_NAME.service"
    
    # Check if service started successfully
    if systemctl is-active --quiet "$SERVICE_NAME.service"; then
        log_message "Service $SERVICE_NAME started successfully"
    else
        log_message "Warning: Service $SERVICE_NAME failed to start"
        systemctl status "$SERVICE_NAME.service"
    fi
fi

log_message "Service creation completed"
echo "Service $SERVICE_NAME has been created successfully."
echo "Use 'systemctl status $SERVICE_NAME' to check its status."

exit 0
```

## Part 6: Troubleshooting Systemd Services

### Common Service Problems and Solutions

#### 1. Service Fails to Start

**Problem**: A service fails to start and shows a "failed" status.

**Troubleshooting Steps**:

```shellscript
# Check the service status for error messages
systemctl status service-name

# View detailed logs for the service
journalctl -u service-name

# Check for syntax errors in the service file
systemd-analyze verify /etc/systemd/system/service-name.service

# Check for permission issues
ls -la /path/to/executable

# Check for missing dependencies
ldd /path/to/executable

# Try starting the service manually to see errors
/path/to/executable
```

#### 2. Service Starts but Keeps Crashing

**Problem**: A service starts but repeatedly crashes and restarts.

**Troubleshooting Steps**:

```shellscript
# Check logs for crash information
journalctl -u service-name -f

# Check resource limits
systemctl show service-name | grep Limit

# Check for file descriptor limits
cat /proc/$(pidof service-name)/limits

# Modify the service to add more debugging
systemctl edit service-name
# Add: Environment=DEBUG=1

# Check for core dumps
coredumpctl list
coredumpctl info service-name
```

#### 3. Service Dependencies Issues

**Problem**: A service fails to start due to dependency issues.

**Troubleshooting Steps**:

```shellscript
# Check service dependencies
systemctl list-dependencies service-name

# Check if required services are running
systemctl status dependency-service

# Check ordering constraints
systemctl show -p After,Before,Wants,Requires service-name

# Modify dependencies if needed
systemctl edit service-name
```

#### 4. Permission Problems

**Problem**: A service fails due to permission issues.

**Troubleshooting Steps**:

```shellscript
# Check the service user and group
systemctl show -p User,Group service-name

# Check file permissions
ls -la /path/to/executable
ls -la /path/to/working/directory

# Check SELinux context
ls -Z /path/to/executable

# Check AppArmor profile
aa-status | grep service-name

# Temporarily disable SELinux to test
setenforce 0
systemctl restart service-name
setenforce 1
```

#### 5. Resource Constraints

**Problem**: A service fails or performs poorly due to resource constraints.

**Troubleshooting Steps**:

```shellscript
# Check resource usage
systemctl status service-name

# Check resource limits
systemctl show service-name | grep Limit

# Check CPU and memory usage
ps aux | grep service-name

# Check for OOM (Out of Memory) kills
journalctl -k | grep -i "out of memory"

# Increase resource limits
systemctl set-property service-name MemoryLimit=2G
systemctl set-property service-name CPUQuota=50%
```

### Systemd Debugging Tools

```shellscript
# Analyze boot time and service startup
systemd-analyze

# Analyze critical chain of services
systemd-analyze critical-chain

# Analyze time spent by each service
systemd-analyze blame

# Verify syntax of unit files
systemd-analyze verify unit-file

# Debug service startup
systemctl start --no-block service-name

# Enable more verbose logging
journalctl -u service-name -o verbose

# Check for failed services
systemctl --failed

# Check for services in activating state
systemctl list-units --state=activating

# Check for services with dependency problems
systemctl list-units --state=inactive
```

## Part 7: Real-World Systemd Service Examples

### Web Server Service (Nginx)

```ini
# /etc/systemd/system/nginx.service
[Unit]
Description=NGINX HTTP and reverse proxy server
After=network.target nss-lookup.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t -q -g 'daemon on; master_process on;'
ExecStart=/usr/sbin/nginx -g 'daemon on; master_process on;'
ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
TimeoutStopSec=5
KillMode=mixed
PrivateTmp=true
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

### Database Service (MySQL/MariaDB)

```ini
# /etc/systemd/system/mariadb.service
[Unit]
Description=MariaDB database server
After=network.target
After=syslog.target

[Service]
Type=notify
User=mysql
Group=mysql
ExecStart=/usr/sbin/mysqld
ExecStartPost=/usr/libexec/mysql-check-upgrade
Restart=on-failure
LimitNOFILE=10000
PrivateTmp=true
OOMScoreAdjust=-500

# Set resource limits
MemoryLimit=2G
CPUQuota=80%

# Security settings
ProtectSystem=full
ProtectHome=true
PrivateDevices=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

### Application Server (Node.js)

```ini
# /etc/systemd/system/nodejs-app.service
[Unit]
Description=Node.js Application
After=network.target
After=mysql.service

[Service]
Type=simple
User=nodejs
Group=nodejs
WorkingDirectory=/opt/nodejs-app
ExecStart=/usr/bin/node /opt/nodejs-app/server.js
Restart=on-failure
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=nodejs-app
Environment=NODE_ENV=production
Environment=PORT=3000
Environment=DB_HOST=localhost
Environment=DB_USER=app
Environment=DB_PASS=secret

# Resource limits
LimitNOFILE=65535
MemoryLimit=1G
CPUQuota=50%

[Install]
WantedBy=multi-user.target
```

### Backup Service with Timer

```ini
# /etc/systemd/system/backup.service
[Unit]
Description=Daily Backup Service
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup-script.sh
User=backup
Group=backup
Nice=19
IOSchedulingClass=idle
```

```ini
# /etc/systemd/system/backup.timer
[Unit]
Description=Run backup daily at 2 AM

[Timer]
OnCalendar=*-*-* 02:00:00
Persistent=true
RandomizedDelaySec=30min

[Install]
WantedBy=timers.target
```

### Load-Balanced Web Application

```ini
# /etc/systemd/system/webapp@.service
[Unit]
Description=Web Application Server %i
After=network.target
After=mysql.service
Requires=mysql.service

[Service]
Type=simple
User=webapp
Group=webapp
WorkingDirectory=/opt/webapp
ExecStart=/usr/bin/python3 /opt/webapp/app.py --port=%i
Restart=on-failure
RestartSec=5
StandardOutput=journal
StandardError=journal
SyslogIdentifier=webapp-%i
Environment=DB_HOST=localhost
Environment=DB_USER=webapp
Environment=DB_PASS=secret
Environment=APP_PORT=%i

[Install]
WantedBy=multi-user.target
```

To start multiple instances:

```shellscript
# Enable and start 4 instances on ports 8001-8004
for i in {8001..8004}; do
    systemctl enable webapp@$i
    systemctl start webapp@$i
done
```

## Part 8: Best Practices for Systemd Service Management

### Service Design Best Practices

1. **Follow the Principle of Least Privilege**

1. Run services as non-root users whenever possible
2. Use specific service users rather than generic ones
3. Grant only the permissions necessary for the service to function



2. **Implement Proper Dependency Management**

1. Use `After` for ordering and `Requires`/`Wants` for dependencies
2. Avoid circular dependencies
3. Use socket activation when appropriate



3. **Design for Resilience**

1. Configure appropriate restart policies
2. Set reasonable timeouts
3. Use health checks when possible



4. **Resource Management**

1. Set appropriate resource limits
2. Consider using cgroups for resource isolation
3. Monitor resource usage and adjust as needed



5. **Security Hardening**

1. Use systemd's security features like `ProtectSystem` and `PrivateTmp`
2. Restrict capabilities to the minimum required
3. Use network namespaces when appropriate





### Service Configuration Best Practices

1. **Standardize Service Files**

1. Use consistent naming conventions
2. Document service purpose and dependencies
3. Include contact information for service owners



2. **Use Override Files Instead of Editing Vendor Files**

1. Create `/etc/systemd/system/service-name.service.d/override.conf` instead of editing files in `/usr/lib/systemd/system/`
2. This ensures updates don't overwrite your changes



3. **Version Control Service Files**

1. Keep service files in a version control system
2. Document changes and reasons
3. Use configuration management tools to deploy



4. **Implement Proper Logging**

1. Configure appropriate log levels
2. Use structured logging when possible
3. Set up log rotation



5. **Document Service Requirements**

1. List required packages
2. Document configuration dependencies
3. Include troubleshooting information





### Service Management Best Practices

1. **Automate Service Deployment**

1. Use configuration management tools (Ansible, Puppet, etc.)
2. Create deployment scripts
3. Test service files in non-production environments first



2. **Implement Monitoring**

1. Set up alerts for service failures
2. Monitor resource usage
3. Track service performance metrics



3. **Regular Service Audits**

1. Review enabled services regularly
2. Check for unnecessary services
3. Verify service configurations against best practices



4. **Maintain Service Documentation**

1. Keep a service catalog
2. Document service dependencies
3. Include startup and shutdown procedures



5. **Plan for Disaster Recovery**

1. Document recovery procedures
2. Test service restoration
3. Keep backups of service configurations





## Part 9: Resources for Further Learning

### Official Documentation

1. **Systemd Man Pages**

1. `man systemd`
2. `man systemctl`
3. `man systemd.unit`
4. `man systemd.service`
5. `man systemd.timer`
6. `man journalctl`



2. **Systemd Project Documentation**

1. [Systemd Official Documentation](https://www.freedesktop.org/software/systemd/man/)



3. **Distribution-Specific Documentation**

1. [RHEL Systemd Documentation](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/managing-services-with-systemd_configuring-basic-system-settings)
2. [Ubuntu Systemd Documentation](https://ubuntu.com/server/docs/service-management)





### Books and Tutorials

1. **"Mastering Systemd"** by Lennart Poettering and Kay Sievers
2. **"Linux Administration Cookbook"** by Adam K. Dean
3. **"Pro Linux System Administration"** by James Turnbull, Peter Lieverdink, and Dennis Matotek


### Online Courses and Tutorials

1. **Linux Foundation Courses**

1. [Linux System Administration](https://training.linuxfoundation.org/training/linux-system-administration/)



2. **Red Hat Training**

1. [Red Hat System Administration II (RH134)](https://www.redhat.com/en/services/training/rh134-red-hat-system-administration-ii)



3. **Digital Ocean Tutorials**

1. [Systemd Essentials](https://www.digitalocean.com/community/tutorials/systemd-essentials-working-with-services-units-and-the-journal)





## Conclusion: Mastering the Service Lifecycle

Systemd service management is a fundamental skill for any Linux engineer. By mastering these concepts, you've gained the ability to:

1. **Control the complete lifecycle** of services from installation to removal
2. **Automate service management** for consistent environments
3. **Troubleshoot service issues** effectively and efficiently
4. **Create custom services** for your specific needs
5. **Implement robust service monitoring** and recovery


Remember these key principles:

1. **Standardization**: Use consistent service configurations
2. **Automation**: Script service management tasks
3. **Security**: Run services with minimal privileges
4. **Resilience**: Design services to recover from failures
5. **Documentation**: Keep track of service configurations and dependencies


As you progress through this 30-day Linux Engineer Training Series, you'll build on this foundation to create increasingly sophisticated systems. The service management skills you've learned today will serve as building blocks for everything from web servers to containerized applications.

Tomorrow, we'll explore process management and monitoring, building on the service management concepts we've covered so far. This will complete your understanding of how software runs and is monitored on modern Linux systems.

Happy service managing!
